using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Text;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.IO;

namespace HCTreeView
{
    // <summary>
    // A Tri-State TreeView designed for on-demand populating of the tree
    // </summary>
    // <remarks>
    // 'Mixed' nodes retain their checked state, meaning they can be checked or unchecked according to their current state
    // Tree can be navigated by keyboard (cursor keys & space)
    // No need to do anything special in calling code
    // </remarks>
    public class HCTreeView : TreeView
    {

        [DllImport("uxtheme.dll", CharSet = CharSet.Unicode, ExactSpelling = true)]
        private static extern int SetWindowTheme(IntPtr hWnd, string appName, string partList);

        // <remarks>
        // CheckedState is an enum of all allowable nodes states
        // </remarks>
        public enum CheckedState : int { UnInitialised = -1, UnChecked, Checked, Mixed };

        // <remarks>
        // IgnoreClickAction is used to ingore messages generated by setting the node.Checked flag in code
        // Do not set <c>e.Cancel = true</c> in <c>OnBeforeCheck</c> otherwise the Checked state will be lost
        // </remarks>
        int IgnoreClickAction = 0;
        // <remarks>

        // TriStateStyles is an enum of all allowable tree styles
        // All styles check children when parent is checked
        // Installer automatically checks parent if all children are checked, and unchecks parent if at least one child is unchecked
        // Standard never changes the checked status of a parent
        // </remarks>
        public enum TriStateStyles : int { Standard = 0, Installer };

        // Create a private member for the tree style, and allow it to be set on the property sheer
        private TriStateStyles TriStateStyle = TriStateStyles.Standard;
        [System.ComponentModel.Category("Tri-State Tree View")]
        [System.ComponentModel.DisplayName("Style")]
        [System.ComponentModel.Description("Style of the Tri-State Tree View")]
        public TriStateStyles TriStateStyleProperty
        {
            get { return TriStateStyle; }
            set { TriStateStyle = value; }
        }

        // <summary>
        // Constructor.  Create and populate an image list
        // </summary>
        public HCTreeView()
            : base()
        {
            SetWindowTheme(Handle, "explorer", null);
            this.HotTracking = true;
            this.FullRowSelect = true;
            StateImageList = new ImageList();
            StateImageList.ColorDepth = ColorDepth.Depth32Bit;
            // populate the image list, using images from the CheckBoxRenderer class
            for (int i = 0; i < 3; i++)
            {
                // Create a bitmap which holds the relevent check box style
                // see http://msdn.microsoft.com/en-us/library/ms404307.aspx and http://msdn.microsoft.com/en-us/library/checkboxrenderer.aspx

                System.Drawing.Bitmap bmp = new System.Drawing.Bitmap(16, 16);
                System.Drawing.Graphics chkGraphics = System.Drawing.Graphics.FromImage(bmp);
                switch (i)
                {
                    // 0,1 - offset the checkbox slightly so it positions in the correct place
                    case 0:
                        CheckBoxRenderer.DrawCheckBox(chkGraphics, new System.Drawing.Point(0, 1), System.Windows.Forms.VisualStyles.CheckBoxState.UncheckedNormal);
                        break;
                    case 1:
                        CheckBoxRenderer.DrawCheckBox(chkGraphics, new System.Drawing.Point(0, 1), System.Windows.Forms.VisualStyles.CheckBoxState.CheckedNormal);
                        break;
                    case 2:
                        CheckBoxRenderer.DrawCheckBox(chkGraphics, new System.Drawing.Point(0, 1), System.Windows.Forms.VisualStyles.CheckBoxState.MixedNormal);
                        break;
                }

                StateImageList.Images.Add(bmp);
            }
            //this.DrawMode = TreeViewDrawMode.OwnerDrawText;
        }
        
        // <summary>
        // Called once before window displayed.  Disables default Checkbox functionality and ensures all nodes display an 'unchecked' image.
        // </summary>
        protected override void OnCreateControl()
        {
            base.OnCreateControl();
            CheckBoxes = false;			// Disable default CheckBox functionality if it's been enabled

            // Give every node an initial 'unchecked' image
            IgnoreClickAction++;	// we're making changes to the tree, ignore any other change requests
            UpdateChildState(this.Nodes, (int)CheckedState.UnChecked, false, true);
            IgnoreClickAction--;
        }

        // <summary>
        // Called after a node is checked.  Forces all children to inherit current state, and notifies parents they may need to become 'mixed'
        // </summary>
        protected override void  OnBeforeCheck(TreeViewCancelEventArgs e)
        {
 	         base.OnBeforeCheck(e);
            if (IgnoreClickAction > 0)
            {
                return;
            }

            IgnoreClickAction++;	// we're making changes to the tree, ignore any other change requests

            // the checked state has already been changed, we just need to update the state index

            // node is either ticked or unticked.  ignore mixed state, as the node is still only ticked or unticked regardless of state of children
            TreeNode tn = e.Node;
            tn.StateImageIndex = !tn.Checked ? (int)CheckedState.Checked : (int)CheckedState.UnChecked;

            // force all children to inherit the same state as the current node
            UpdateChildState(e.Node.Nodes, e.Node.StateImageIndex, !e.Node.Checked, false);

            // populate state up the tree, possibly resulting in parents with mixed state
            UpdateParentState(e.Node.Parent);

            IgnoreClickAction--;
        }
        // <summary>
        // Called after a node is expanded.  Ensures any new nodes display an 'unchecked' image
        // </summary>
        protected override void  OnBeforeExpand(TreeViewCancelEventArgs e)
        {
            
 	         base.OnBeforeExpand(e);
            // If any child node is new, give it the same check state as the current node
            // So if current node is ticked, child nodes will also be ticked

            IgnoreClickAction++;	// we're making changes to the tree, ignore any other change requests
            UpdateChildState(e.Node.Nodes, e.Node.StateImageIndex, e.Node.Checked, true);
            IgnoreClickAction--;
        }

        // <summary>
        // Helper function to replace child state with that of the parent
        // </summary>
        protected void UpdateChildState(TreeNodeCollection Nodes, int StateImageIndex, bool Checked, bool ChangeUninitialisedNodesOnly)
        {
            foreach (TreeNode tnChild in Nodes)
            {
                if (!ChangeUninitialisedNodesOnly || tnChild.StateImageIndex == -1)
                {
                    tnChild.StateImageIndex = StateImageIndex;
                    tnChild.Checked = Checked;	// override 'checked' state of child with that of parent

                    if (tnChild.Nodes.Count > 0)
                    {
                        UpdateChildState(tnChild.Nodes, StateImageIndex, Checked, ChangeUninitialisedNodesOnly);
                    }
                }
            }
        }

        // <summary>
        // Helper function to notify parent it may need to use 'mixed' state
        // </summary>
        protected void UpdateParentState(TreeNode tn)
        {
            // Node needs to check all of it's children to see if any of them are ticked or mixed
            if (tn == null)
                return;

            int OrigStateImageIndex = tn.StateImageIndex;

            int UnCheckedNodes = 0, CheckedNodes = 0, MixedNodes = 0;

            // The parent needs to know how many of it's children are Checked or Mixed
            foreach (TreeNode tnChild in tn.Nodes)
            {
                if (tnChild.StateImageIndex == (int)CheckedState.Checked)
                    CheckedNodes++;
                else if (tnChild.StateImageIndex == (int)CheckedState.Mixed)
                {
                    MixedNodes++;
                    break;
                }
                else
                    UnCheckedNodes++;
            }

            if (TriStateStyle == TriStateStyles.Installer)
            {
                // In Installer mode, if all child nodes are checked then parent is checked
                // If at least one child is unchecked, then parent is unchecked
                if (MixedNodes == 0)
                {
                    if (UnCheckedNodes == 0)
                    {
                        // all children are checked, so parent must be checked
                        tn.Checked = true;
                    }
                    else
                    {
                        // at least one child is unchecked, so parent must be unchecked
                        tn.Checked = false;
                    }
                }
            }

            // Determine the parent's new Image State
            if (MixedNodes > 0)
            {
                // at least one child is mixed, so parent must be mixed
                tn.StateImageIndex = (int)CheckedState.Mixed;
            }
            else if (CheckedNodes > 0 && UnCheckedNodes == 0)
            {
                // all children are checked
                if (tn.Checked)
                    tn.StateImageIndex = (int)CheckedState.Checked;
                else
                    tn.StateImageIndex = (int)CheckedState.Mixed;
            }
            else if (CheckedNodes > 0)
            {
                // some children are checked, the rest are unchecked
                tn.StateImageIndex = (int)CheckedState.Mixed;
            }
            else
            {
                // all children are unchecked
                if (tn.Checked)
                    tn.StateImageIndex = (int)CheckedState.Mixed;
                else
                    tn.StateImageIndex = (int)CheckedState.UnChecked;
            }

            if (OrigStateImageIndex != tn.StateImageIndex && tn.Parent != null)
            {
                // Parent's state has changed, notify the parent's parent
                UpdateParentState(tn.Parent);
            }
        }

        // <summary>
        // Called on keypress.  Used to change node state when Space key is pressed
        // Invokes OnAfterCheck to do the real work
        // </summary>
        protected override void OnKeyDown(KeyEventArgs e)
        {
            base.OnKeyDown(e);

            // is the keypress a space?  If not, discard it
            if (e.KeyCode == Keys.Space)
            {
                // toggle the node's checked status.  This will then fire OnAfterCheck
                SelectedNode.Checked = !SelectedNode.Checked;
            }
        }

        // <summary>
        // Called when node is clicked by the mouse.  Does nothing unless the image was clicked
        // Invokes OnAfterCheck to do the real work
        // </summary>
        protected override void OnNodeMouseClick(TreeNodeMouseClickEventArgs e)
        {
            base.OnNodeMouseClick(e);

            // is the click on the checkbox?  If not, discard it
            TreeViewHitTestInfo info = HitTest(e.X, e.Y);
            if (info == null || info.Location != TreeViewHitTestLocations.StateImage)
            {
                return;
            }

            // toggle the node's checked status.  This will then fire OnAfterCheck
            TreeNode tn = e.Node;
            tn.Checked = !tn.Checked;
        }

    }
    /// <summary>
    /// ShellUtilities contains routines to interact with the Windows Shell.
    /// </summary>
    public static class ShellUtilities
    {
        /// <summary>
        /// Execute the default verb on the file or directory identified by the given path.
        /// For documents, this will open them with their normal application. For executables,
        /// this will cause them to run.
        /// </summary>
        /// <param name="path">The file or directory to be executed</param>
        /// <returns>Values &lt; 31 indicate some sort of error. See ShellExecute() documentation for specifics.</returns>
        /// <remarks>The same effect can be achieved by <code>System.Diagnostics.Process.Start(path)</code>.</remarks>
        public static int Execute(string path)
        {
            return ShellUtilities.Execute(path, "");
        }

        /// <summary>
        /// Execute the given operation on the file or directory identified by the given path.
        /// Example operations are "edit", "print", "explore".
        /// </summary>
        /// <param name="path">The file or directory to be operated on</param>
        /// <param name="operation">What operation should be performed</param>
        /// <returns>Values &lt; 31 indicate some sort of error. See ShellExecute() documentation for specifics.</returns>
        public static int Execute(string path, string operation)
        {
            IntPtr result = ShellUtilities.ShellExecute(0, operation, path, "", "", SW_SHOWNORMAL);
            return result.ToInt32();
        }

        /// <summary>
        /// Get the string that describes the file's type.
        /// </summary>
        /// <param name="path">The file or directory whose type is to be fetched</param>
        /// <returns>A string describing the type of the file, or an empty string if something goes wrong.</returns>
        public static String GetFileType(string path)
        {
            SHFILEINFO shfi = new SHFILEINFO();
            int flags = SHGFI_TYPENAME;
            IntPtr result = ShellUtilities.SHGetFileInfo(path, 0, out shfi, Marshal.SizeOf(shfi), flags);
            if (result.ToInt32() == 0)
                return String.Empty;
            else
                return shfi.szTypeName;
        }

        /// <summary>
        /// Return the icon for the given file/directory.
        /// </summary>
        /// <param name="path">The full path to the file whose icon is to be returned</param>
        /// <param name="isSmallImage">True if the small (16x16) icon is required, otherwise the 32x32 icon will be returned</param>
        /// <param name="useFileType">If this is true, only the file extension will be considered</param>
        /// <returns>The icon of the given file, or null if something goes wrong</returns>
        public static Icon GetFileIcon(string path, bool isSmallImage, bool useFileType)
        {
            int flags = SHGFI_ICON;
            if (isSmallImage)
                flags |= SHGFI_SMALLICON;

            int fileAttributes = 0;
            if (useFileType)
            {
                flags |= SHGFI_USEFILEATTRIBUTES;
                if (!System.IO.File.Exists(path))
                    fileAttributes = FILE_ATTRIBUTE_DIRECTORY;
                else
                    fileAttributes = FILE_ATTRIBUTE_NORMAL;
            }

            SHFILEINFO shfi = new SHFILEINFO();
            IntPtr result = ShellUtilities.SHGetFileInfo(path, fileAttributes, out shfi, Marshal.SizeOf(shfi), flags);
            if (result.ToInt32() == 0)
                return null;
            else
                try
                {
                    return Icon.FromHandle(shfi.hIcon);
                }
                catch (System.Exception ex)
                {
                    return null;
                }
        }

        /// <summary>
        /// Return the index into the system image list of the image that represents the given file.
        /// </summary>
        /// <param name="path">The full path to the file or directory whose icon is required</param>
        /// <returns>The index of the icon, or -1 if something goes wrong</returns>
        /// <remarks>This is only useful if you are using the system image lists directly. Since there is
        /// no way to do that in .NET, it isn't a very useful.</remarks>
        public static int GetSysImageIndex(string path)
        {
            SHFILEINFO shfi = new SHFILEINFO();
            int flags = SHGFI_ICON | SHGFI_SYSICONINDEX;
            IntPtr result = ShellUtilities.SHGetFileInfo(path, 0, out shfi, Marshal.SizeOf(shfi), flags);
            if (result.ToInt32() == 0)
                return -1;
            else
                return shfi.iIcon;
        }

        #region Native methods

        private const int SHGFI_ICON = 0x00100;     // get icon
        private const int SHGFI_DISPLAYNAME = 0x00200;     // get display name
        private const int SHGFI_TYPENAME = 0x00400;     // get type name
        private const int SHGFI_ATTRIBUTES = 0x00800;     // get attributes
        private const int SHGFI_ICONLOCATION = 0x01000;     // get icon location
        private const int SHGFI_EXETYPE = 0x02000;     // return exe type
        private const int SHGFI_SYSICONINDEX = 0x04000;     // get system icon index
        private const int SHGFI_LINKOVERLAY = 0x08000;     // put a link overlay on icon
        private const int SHGFI_SELECTED = 0x10000;     // show icon in selected state
        private const int SHGFI_ATTR_SPECIFIED = 0x20000;     // get only specified attributes
        private const int SHGFI_LARGEICON = 0x00000;     // get large icon
        private const int SHGFI_SMALLICON = 0x00001;     // get small icon
        private const int SHGFI_OPENICON = 0x00002;     // get open icon
        private const int SHGFI_SHELLICONSIZE = 0x00004;     // get shell size icon
        private const int SHGFI_PIDL = 0x00008;     // pszPath is a pidl
        private const int SHGFI_USEFILEATTRIBUTES = 0x00010;     // use passed dwFileAttribute
        //if (_WIN32_IE >= 0x0500)
        private const int SHGFI_ADDOVERLAYS = 0x00020;     // apply the appropriate overlays
        private const int SHGFI_OVERLAYINDEX = 0x00040;     // Get the index of the overlay

        private const int FILE_ATTRIBUTE_NORMAL = 0x00080;     // Normal file
        private const int FILE_ATTRIBUTE_DIRECTORY = 0x00010;     // Directory

        private const int MAX_PATH = 260;

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        private struct SHFILEINFO
        {
            public IntPtr hIcon;
            public int iIcon;
            public int dwAttributes;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = MAX_PATH)]
            public string szDisplayName;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 80)]
            public string szTypeName;
        }

        private const int SW_SHOWNORMAL = 1;

        [DllImport("shell32.dll", CharSet = CharSet.Auto)]
        private static extern IntPtr ShellExecute(int hwnd, string lpOperation, string lpFile,
            string lpParameters, string lpDirectory, int nShowCmd);

        [DllImport("shell32.dll", CharSet = CharSet.Auto)]
        private static extern IntPtr SHGetFileInfo(string pszPath, int dwFileAttributes,
            out SHFILEINFO psfi, int cbFileInfo, int uFlags);

        #endregion
    }
}
